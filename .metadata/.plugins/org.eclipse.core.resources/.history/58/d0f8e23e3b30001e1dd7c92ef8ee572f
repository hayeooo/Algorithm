package Recursion;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * SWEA 1210: Ladder1
 * 방향 전환을 하며 X 표시에 도착하게 되는 사다리 찾기
 * 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환
 * 방향 전환 이후에 아래 방향으로만 이동하며, 바닥에 도착하면 멈추게 된다.
 * 
 * 1. 아래로 가는 재귀함수 & 오른쪽으로 가는 재귀함수
 * 2. visited 배열을 사용하여 이미 방문한 경로는 생략
 * */
public class SWEA_1210_Ladder1 {
	static BufferedReader br;
	static StringTokenizer st;
	static final int T=10;
	static int[][] board;
	static boolean exists;
	static boolean[][] visited;
	
	public static void main(String[] args) throws IOException {
		br=new BufferedReader(new InputStreamReader(System.in));
		board=new int[100][100];
		
		for (int tc=1;tc<=T;tc++) {
			visited=new boolean[100][100];
			int test_case=Integer.parseInt(br.readLine());
			
			for (int row=0;row<100;row++) {
				st=new StringTokenizer(br.readLine()," ");
				for (int col=0;col<100;col++) {
					board[row][col]=Integer.parseInt(st.nextToken());
				}
			}
			
			exists=false;
			for (int col=0;col<100;col++) {
				if (board[0][col]==1) {
					goDown(0,col);
					visited[0][col]=true;
					if (exists) {
						System.out.printf("#%d %d%n",test_case,col);
						break;
					}
				}
			}
		}
	}

	public static void goDown(int cx,int cy) {
		if (cy>99 || cx>99) return;
		if (cx==99 && board[cx][cy]==2) {
			exists=true;
			return;
		}
		visited[cx][cy]=true;
		if (cy+1<=99 && !visited[cx][cy+1] && board[cx][cy+1]==1) {
			goRight(cx,cy+1);
		}
		if (cx+1<=99 && !visited[cx+1][cy] && board[cx+1][cy]==1) {
			goDown(cx+1,cy);
		}else {
			return;
		}
	}

	public static void goRight(int cx, int cy) {

	}

}
